
### 添加页面

我们的目标是给我们的`Phoenix`应用增加两个新的页面，一个是纯静态页面，另一个则从`url`里面截取一部分作为输入，然后传递给模板显示。从这两个简单的例子中我们将会熟悉一个`Phoenix`应用的基本组件: 路由，控制器，视图以及模板。

当我们用命令产生一个`Phoenix`应用后，默认的目录结构如下：
```bash
├── _build
├── config
├── deps
├── lib
├── priv
├── test
├── web
```
我们教程中涉及的大部分内容都在`web`目录下，她的结构展开如下图：

```bash
├── channels
├── controllers
│   └── page_controller.ex
├── models
├── router.ex
├── templates
│   ├── layout
│   │   └── app.html.eex
│   └── page
│       └── index.html.eex
└── views
|   ├── error_view.ex
|   ├── layout_view.ex
|   └── page_view.ex
└── web.ex
```

在 `controllers`,`templates`和`views`目录里的所有文件都是用于创建`Welcome to Phenix`欢迎页面的,我们之后将重用这里的一些代码。

All of our application's static assets live in priv/static in the directory appropriate for each type of file - css, images or js. We place assets that require a build phase into web/static, and the source files are built into their respective app.js / app.css bundles within priv/static. We won't be making any changes here for now, but it is good to know where to look for future reference.

我们应用所需的所有静态资源都在 `priv/static` 目录下（按照css,images或者js分类）, .... , 我们现在不会做任何改变，只是留个印象。

```bash
priv
└── static
    └── images
        └── phoenix.png

```
```
web
└── static
    ├── css
    |   └── app.scss
    ├── js
    │   └── app.js
    └── vendor
        └── phoenix.js
```
`lib`目录也值得我们了解一下，它包含了我们应用的端点文件( endpoint 更好的翻译？)以及应用文件（用来启动和监视项目目录）lib/hello_phoenix.ex.

```Bash
lib
├── hello_phoenix
|   ├── endpoint.ex
│   └── repo.ex
└── hello_phoenix.ex

```
准备的差不多了，现在让我们编写一个新的 `Phoenix` 页面吧！

#### 一个新路由
Routes map unique HTTP verb/path pairs to controller/action pairs which will handle them. Phoenix generates a router file for us in new applications at web/router.ex. This is where we will be working for this section.

路由将给定并唯一的 `HTTP 动词/路径(verb/path)` 映射到处理他们的 `控制器和动作(controller/action)`, `Phoenix`的路由配置信息在 `web/router.ex`文件，让我们打开来看看。

欢迎页面对应的路由是这条语句：
```Elixir
get "/", PageController, :index
```
让我们看看这代表什么意思呢，浏览器访问 `http://localhost:4000/` 会给我们网站的根目录发出一个`GET`请求，这个请求会被 `index` 函数处理，后者定义在 `web/controllers/page_controller.ex`文件中.

我们要建立的页面功能是：当浏览器访问 `http://localhost:4000/hello`时，简单的在页面上显示'Hello World from Phoenix'.

首先我们要为这个页面增加一个路由，现在`web/route.ex`看起来如下：

```Elixir
defmodule HelloPhoenix.Router do
  use HelloPhoenix.Web, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", HelloPhoenix do
    pipe_through :browser # Use the default browser stack

    get "/", PageController, :index
  end

  # Other scopes may use custom stacks.
  # scope "/api", HelloPhoenix do
  #   pipe_through :api
  # end
end

```

现在，我们先不管 `pipelines`和`scope`部分（这些内容详见 Routing部分(todo)）.

让我为 `/hello` 的`GET`请求创建一个路由吧(对应的文件--HelloPhoenix文件稍后创建).

```Elixir
get "/hello", HelloController, :index
```
添加后，`router.ex`文件的 `scope '/'` 部分看起来应该是这个样子：

```Elixir
scope "/", HelloPhoenix do
  pipe_through :browser # Use the default browser stack

  get "/", PageController, :index
  get "/hello", HelloController, :index
end
```
#### 一个新控制器

`控制器`里面包含了`Elixir`模块，动作(action)和 
`Elixir`函数，动作（`action`）的作用是收集和处理渲染页面所需的数据和任务,我们现在要建立一个模块 `HelloPhoenix.HelloController`,里面包含 `index/2` 动作(`action`)(这里写/2是Elixir写法，意思是需要两个参数)。

具体的，我们建立文件`web/controllers//hello_controller.ex`,然后加入以下内容：

```Elixir
defmodule HelloPhoenix.HelloController do
  use HelloPhoenix.Web, :controller

  def index(conn, _params) do
    render conn, "index.html"
  end
end
```

我们会在 `controller`章节中详细讨论 `HelloPhoenix.Web, :controller`语句，现在我们先来看看 `index/2 `函数。

所有的 `controller actions` 都接受两个参数，第一个是 `conn`--一个包含了大量`请求（request）`信息的结构体。第二个是`params`--请求参数，我们的例子不需要`params`,所以加一个前缀 `_`表示忽略该参数，否则编译器会报警告。

这个动作（action）的核心是 `render conn, "index.html"`,Phoenix 会根据这条语句寻找一个叫做`index.html.eex`的模板并且渲染出来，查找规则是遵循控制器的命名,即 `web/templates/hello`

>注意这里用原子(atom)的简写法也是可以的，比如`render conn, :index`,这是渲染机制就会根据请求头的规则自动寻找合适的模板,如`index.html`或者`index.json`，等等。

负责具体渲染的模块是`视图(views)`,我们现在就来建立一个。

#### 新的视图

`视图(views)`负责几个重要的工作，她渲染模板，并且作为控制器里`裸数据(raw data)`的处理层，一些有用的函数将这些数据处理后供模板使用。

举个栗子，比如我们有一个包含了 `first_name` 字段和`last_name`的用户数据，然后在模板里，我们想显示这个用户的全名(full name)。我们可以在模板里写函数把它们拼接起来，但更好的办法是在`视图`里写一个函数去做这件事，然后在模板里调用这个函数，这种解决方案会让模板变得干净和灵活。

为了能让我们的 `HelloController`渲染模板，我们需要一个 `HelloView`。这里的命名同样具有特殊意义--'Hello'要和控制器的'Hello'相对应，让我们先创建一个`web/views/hello_view.ex`文件（稍后解释细节），内容如下：

```Elixir
defmodule HelloPhoenix.HelloView do
  use HelloPhoenix.Web, :view
end
```
#### 一个新模板

Phoenix默认使用的模板引擎是`eex`,意思是`嵌入式 Elixir（embedded Elixir）`,所以我们的模板文件都会带有`.eex`后缀。

模板被视图所限定，视图又被控制器所限定，在实际开发中，我们通常根据控制器的名字在`web/templates`目录下建立一个文件夹。在我们这个hello应用中，这意味着我们需要在`web/templates`目录下面建立一个hello文件夹，再在里面建立一个`index.htmleex`文件，内容如下。

```html
<div class="jumbotron">
  <h2>Hello World, from Phoenix!</h2>
</div>

```
现在我们有了`路由`，`控制器`,`视图`和`模板`，我们应该可以通过浏览器访问 `http://localhost:4000/hello`看到新的欢迎页面了！（如果你之前停止了服务器可以通过`mix phoenix.server`重启）。

图片占位！



这里有些知识点需要注意：首先，改动代码以后，我们并不需要重启服务器，`Phoenix`有代码热更新(code re-loading)功能。另外，尽管我们的 `index.html.eex`文件只包含了一个`div`标签，我们依然得到了一个"完整的"页面，我们的模板被渲染进了应用布局(application layout) -- `web/templates/layout/app.html.eex`。 如果你打开她，就会发现有这样一行内容`<%= @inner %>`, 意思是你自己的模板会被"插入"到这里。


#### 另一个新页面

让我们为我们的应用增加一点复杂性。我们建立一个新的页面，她的功能是识别我们url的一部分，将她作为'信息'通过给控制器传递给模板，然后显示出来。

就像我们之前做的那样，先添加一个路由。

#### 新的路由
在这个练习中，我们复用之前创建的 `HelloController` 然后添加一个新的 show  action, 增加的路由如下：

```Elixir
scope "/", HelloPhoenix do
  pipe_through :browser # Use the default browser stack.

  get "/", PageController, :index
  get "/hello", HelloController, :index
  get "/hello/:messenger", HelloController, :show
end
```
>注意这个原子写法：`:messenger`, Phoenix 会把 messenger 作为键，并把用户输入在这个地址后的任何输入作为值，组成一个`字典结构(dict)`传递给控制器。

比如，如果我们在浏览器输入 `http://localhost:4000/hello/Frank`, ":messenger"的值就会是 "Frank" 。

#### 新的 action

新的请求会被 `HelloPhoenix.HelloController` 的 `show` action 处理，我们复用之前的 `web/controllers/hello_controller.ex`文件，在其中添加 show action 如下（注意其中字典的写法）：

```Elixir
def show(conn, %{"messenger" => messenger}) do
  render conn, "show.html", messenger: messenger
end
```
>注意如果你想要得到 params 的所有参数并绑定 messenger 变量，我们可以这样定义（译者擅自注：类似javascript es6 的写法）：

```Elixir
def show(conn, %{"messenger" => messenger} = params) do
  ...
end
```
>注意所有的 keys 都是字符串，还有这里的`＝` 不是赋值符号，而是`模式匹配`。

#### 新的模板
终于到最后一步了，一个新的模板。根据命名规则，`Phoenix`会去 `web/templates/hello`文件夹下寻找`show.html.eex`文件。她和之前的 `index.eex`模板长的很像，除了一个 Elixir 表达式：`<%= %>` ,注意标签里有个`<%=`符号。这表示这个便签里的 Elixir 代码会被执行并且结果会覆盖这个标签，如果我们不加 `=` ,里面的 Elixir 代码依然会执行，但是结果却不会出现在页面上。


`show.html.eex`文件的内容如下：
```html
<div class="jumbotron">
  <h2>Hello World, from <%= @messenger %>!</h2>
</div>
```
这里的@messenger并不是什么模块的属性，而是一个元编程的语法糖，表示 `dict.get(assigns, :messenger)`。这是这种写法对于模板来说更加友好。

一切就绪，现在让我们打开 `http://localhost:4000/hello/Frank`来检验成果吧！

图片占位！




















